import os
import cv2
import numpy as np
import tensorflow as tf
import tensorflow_addons as tfa
import pandas as pd
import matplotlib.pyplot as plt
from pathlib import *
from tqdm import tqdm

def load_model(pretrained_model):  
    
    #input = tf.keras.layers.Input(shape=(224, 224, 3))
    #pretrained_model = tf.keras.applications.MobileNetV2(input_tensor=input, include_top = False, weights='imagenet')
    #pretrained_model.trainable=False
    x = pretrained_model.output
    x = tf.keras.layers.Flatten()(x)
    x = tf.keras.layers.Dense(4096, activation=None)(x) # No activation on final dense layer
    prediction_layer = tf.keras.layers.Lambda(lambda x: tf.math.l2_normalize(x, axis=1))(x) # L2 normalize embeddings

    model = tf.keras.models.Model(pretrained_model.input, prediction_layer)

    return model


def load_weight(weight_path):
    return tf.keras.models.load_model(weight_path)

def save_ref_image_emb(model, data_path):
    imgs = []
    name = []
    #data_path = './referenceImgs/'
    test_list =[str(file) for file in Path(data_path).glob('*.png')]

    for i in range(1,10):
        img = cv2.imread(data_path + str(i)+'.png')#,cv2.IMREAD_GRAYSCALE)
    #     img = cv2.resize(img, dsize=(105, 105),interpolation = cv2.INTER_AREA)
        img = cv2.resize(img, dsize=(224,224))
    #     print(img.shape)
        img = img /255.0
        imgs.append(img)
        
    #     print(data_path + str(i)+'.png')

    emb_ref = model.predict(np.stack(imgs))
    return emb_ref

def inference(all_embeddings, binary_file, emb_ref, classes):
    label_path = '../trainLabels.csv'
    labels = pd.read_csv('./trainLabels.csv')
    labell = np.array(labels['Class'].loc[labels['Id']==binary_file[:-6]])
    y_true = []
    y_pred = []
    for label, embs in enumerate(all_embeddings):
        y_pred_per_label = []
        for i in tqdm(range(embs.shape[0]), desc=f"Calculating Distance: {classes[label]}"):
            distances =  np.linalg.norm(emb_ref - embs[i:i+1], axis=1)
            y_pred_per_label.append(np.argmin(distances) + 1)
        y_true.append(np.full([embs.shape[0]], label))
        y_pred.append(np.array(y_pred_per_label))
    y_true = np.concatenate(y_true)
    y_pred = np.concatenate(y_pred)

#     return y_true, y_pred
    return labell, y_pred

