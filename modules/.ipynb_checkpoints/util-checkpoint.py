import matplotlib.pyplot as plt
import os
import numpy as np
from PIL import Image
from math import log
import cv2
import tensorflow as tf
import tensorflow_addons as tfa
import pandas as pd
import matplotlib.pyplot as plt
from modules.model import *

def convert_binary_to_image(binary_file):
    array = []
    for line in binary_file:
        xx = line.split()
        if(len(xx)==17):
            array.append([int(i,16) if i!= '??' else 0 for i in xx[1:]])
    array = np.array(array)
    if(array.shape[1]!=16):
        return
    b=int((array.shape[0]*16)**(0.5))
    b=2**(int(log(b)/log(2))+1)
    a=int(array.shape[0]*16/b)
    array=array[:a*b//16,:]
    array=np.reshape(array,(a,b))
    im = Image.fromarray(np.uint8(array))
    im = im.resize((224, 224), Image.BILINEAR)
    img = Image.new("RGB",im.size)
    img.paste(im)
    
    #     im.save(root+name+'.png', "PNG")
    return img

def gridfigure(ref_path):
    class_name =['Ramnit','Lollipop','Kelhos_ver3','Vundo','Simda','Tracur','Kelihos_ver1','Obfuscator.ACY','Gatak']
    malware_imgs = [Image.open(os.path.join(ref_path, filename + '.png')).resize((105, 105)) for filename in ['1','2','3','4','5','6','7','8','9']]
    fig = plt.figure(figsize=(10, 10))
    gs = plt.GridSpec(3, 3)
    fig.suptitle("Reference Image",fontsize = 16)
    for i in range(9):
        ax = fig.add_subplot(gs[int(i/3), i%3])
        ax.imshow(malware_imgs[i], cmap = 'gray')
        ax.axis('off')
        ax.set_title(class_name[i],fontsize =14)

def triplet_generator(dataset_imgs, batch_size, min_pairs):
    assert min_pairs < batch_size // 2
    malware_types_count = len(classes)
    while True:
        
        anchors_ids = np.random.choice(malware_types_count, min_pairs)
        
        (unique, count) = np.unique(anchors_ids, return_counts = True)
        
        # Anchor data and Positive data randomly selection for calculating the Triplet loss
        anchor_pos_img = []
        anchor_pos_labels = []
        
        positive_img = []
        positive_labels = []
        for i, un in enumerate(unique):
            ids = np.random.choice(len(dataset_imgs[classes[un]]), count[i]*2)
            imgs = dataset_imgs[classes[un]][ids]
            anchor_pos_img.append(imgs)
            anchor_pos_labels.append(np.full(count[i]*2, un))
            
            ids_pos = np.random.choice(len(dataset_imgs[classes[un]]), count[i]*2)
            imgs = dataset_imgs[classes[un]][ids_pos]
            positive_img.append(imgs)
            positive_labels.append(np.full(count[i]*2, un))
            
        anchor_pos_img = np.concatenate(anchor_pos_img)
        anchors_imgs = anchor_pos_img[:min_pairs]
        anchor_pos_labels = np.concatenate(anchor_pos_labels)
        
        positive_img = np.concatenate(positive_img)
        positive_imgs = positive_img[:min_pairs]
        positive_labels = np.concatenate(positive_labels)
        
        
        negative_ids = np.random.choice(malware_types_count, batch_size - (min_pairs*2))
        (unique, count) = np.unique(negative_ids, return_counts=True)
        
        negative_imgs = []
        negative_labels = []
        for i, un in enumerate(unique):
            ids = np.random.choice(len(dataset_imgs[classes[un]]), count[i])
            imgs = dataset_imgs[classes[un]][ids]
            negative_imgs.append(imgs)
            negative_labels.append(np.full(count[i], un))
            
        negative_imgs = np.concatenate(negative_imgs)
        negative_labels = np.concatenate(negative_labels)
        
        yield tf.concat([anchors_imgs, positive_imgs, negative_imgs], axis=0),  tf.concat([anchor_pos_labels, negative_labels], axis=0)
        
        
def visualize(num, binary_files, emb_ref, classes, model, data_path = './test_dataset/'):
    binary_file = binary_files[num]
    file = open(data_path + binary_file)
    binary_img = convert_binary_to_image(file)
    binary_img = np.expand_dims(np.array(binary_img)/255.0, axis = 0)
    #plt.imshow(binary_img[0], cmap = 'gray')
    predicted_emb = model.predict(binary_img)
    predicted_emb = np.expand_dims(predicted_emb, axis=0)
    real_label, predicted_label = inference(predicted_emb, binary_file,  emb_ref, classes)
    plt.imshow(binary_img[0], cmap = 'gray')
    plt.title('Predicted : '+ str(predicted_label) + '  Label : ' + str(real_label))